import 'package:flutter/material.dart';
import 'package:flutter_math_fork/flutter_math.dart';
import 'package:test_rendering/data/content_repository.dart';
import 'package:test_rendering/models/content.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Auto Text and LaTeX Renderer',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Auto Text and LaTeX Renderer'),
        ),
        body: const Padding(
          padding: EdgeInsets.all(16.0),
          child: ContentRenderer(),
        ),
      ),
    );
  }
}

class ContentRenderer extends StatelessWidget {
  const ContentRenderer({super.key});

  @override
  Widget build(BuildContext context) {
    final ContentRepository repository = ContentRepository();

    return FutureBuilder<List<Content>>(
      future: repository.fetchContents(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        } else if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text('No content available.'));
        }

        final List<Content> contents = snapshot.data!;

        return ListView.builder(
          shrinkWrap: true,
          itemCount: contents.length,
          itemBuilder: (context, index) {
            final content = contents[index];
            return _buildContentCard(content);
          },
        );
      },
    );
  }

  Widget _buildContentCard(Content content) {
    // 문제 번호 읽기
    String nr = content.nr.toString(); // ?? ''; // null 가능성을 고려하여 초기화

    // 문제 번호를 숫자 형식으로 변환 (예: "09")
    String questionNumber =
        nr.length >= 8 ? int.parse(nr.substring(6, 8)).toString() : '??';

    // 제목 가져오기
    String title = content.title; // null 가능성이 없으므로 null-aware 연산자 제거

    // 문제 내용과 답변 내용 파싱
    final List<InlineSpan> questionSpans = _parseMixedContent(content.ques);
    final List<InlineSpan> answerSpans = _parseMixedContent(content.ans);

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 문제 번호와 제목
            Text(
              "$questionNumber. $title",
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 10),

            // 문제 내용
            RichText(
              text: TextSpan(
                children: questionSpans,
                style: const TextStyle(fontSize: 18, color: Colors.black),
              ),
            ),
            const SizedBox(height: 10),

            // 문제 이미지
            if (content.qImgPath != null)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Image.asset(content.qImgPath!),
              ),

            const SizedBox(height: 20),

            // 답변 내용
            RichText(
              text: TextSpan(
                children: answerSpans,
                style: const TextStyle(fontSize: 18, color: Colors.black),
              ),
            ),
            const SizedBox(height: 10),

            // 답변 이미지
            if (content.aImgPath != null)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Image.asset(content.aImgPath!),
              ),
          ],
        ),
      ),
    );
  }

  List<InlineSpan> _parseMixedContent(String? content) {
    // null 값을 처리하기 위해 기본값 제공
    final regex = RegExp(r'(\$.*?\$|\\.*?\b|P_a=.*?\[kVA\])');
    final matches = regex.allMatches(content ?? '');

    int lastIndex = 0;
    final List<InlineSpan> spans = [];

    for (final match in matches) {
      if (match.start > lastIndex) {
        spans.add(TextSpan(text: content!.substring(lastIndex, match.start)));
      }

      final equation = match.group(0);
      if (equation != null) {
        spans.add(_buildMathWidget(equation));
      }

      lastIndex = match.end;
    }

    if (lastIndex < content!.length) {
      spans.add(TextSpan(text: content.substring(lastIndex)));
    }

    return spans;
  }

  InlineSpan _buildMathWidget(String equation) {
    if (equation.startsWith(r'$') && equation.endsWith(r'$')) {
      equation = equation.substring(1, equation.length - 1);
    }

    return WidgetSpan(
      child: Container(
        padding: const EdgeInsets.only(bottom: 2.0),
        child: Math.tex(
          equation,
          textStyle: const TextStyle(fontSize: 18),
        ),
      ),
      alignment: PlaceholderAlignment.baseline,
      baseline: TextBaseline.alphabetic,
    );
  }
}
///////////////////// 배경색 영역별 추가
import 'package:flutter/material.dart';
import 'package:flutter_math_fork/flutter_math.dart';
import 'package:test_rendering/data/content_repository.dart';
import 'package:test_rendering/models/content.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Auto Text and LaTeX Renderer',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Auto Text and LaTeX Renderer'),
        ),
        body: const Padding(
          padding: EdgeInsets.all(16.0),
          child: ContentRenderer(),
        ),
      ),
    );
  }
}

class ContentRenderer extends StatelessWidget {
  const ContentRenderer({super.key});

  @override
  Widget build(BuildContext context) {
    final ContentRepository repository = ContentRepository();

    return FutureBuilder<List<Content>>(
      future: repository.fetchContents(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        } else if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text('No content available.'));
        }

        final List<Content> contents = snapshot.data!;

        return ListView.builder(
          shrinkWrap: true,
          itemCount: contents.length,
          itemBuilder: (context, index) {
            final content = contents[index];
            return _buildContentCard(content);
          },
        );
      },
    );
  }

  Widget _buildContentCard(Content content) {
    // 문제 번호 읽기
    String nr = content.nr.toString();

    // 문제 번호를 숫자 형식으로 변환 (예: "09")
    String questionNumber =
        nr.length >= 8 ? int.parse(nr.substring(6, 8)).toString() : '??';

    // 제목 가져오기
    String title = content.title;

    // 문제 내용과 답변 내용 파싱
    final List<InlineSpan> questionSpans = _parseMixedContent(content.ques);
    final List<InlineSpan> answerSpans = _parseMixedContent(content.ans);

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 문제 번호와 제목
            Text(
              "$questionNumber. $title",
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 10),

            // 문제 영역 전체 (내용 + 이미지)
            Container(
              color: Colors.grey[200],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // 문제 내용
                  RichText(
                    text: TextSpan(
                      children: questionSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  const SizedBox(height: 10),

                  // 문제 이미지
                  if (content.qImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.qImgPath!),
                    ),
                ],
              ),
            ),

            const SizedBox(height: 20),

            // 답변 영역 전체 (내용 + 이미지)
            Container(
              color: Colors.teal[50],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // 답변 내용
                  RichText(
                    text: TextSpan(
                      children: answerSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  const SizedBox(height: 10),

                  // 답변 이미지
                  if (content.aImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.aImgPath!),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<InlineSpan> _parseMixedContent(String? content) {
    // null 값을 처리하기 위해 기본값 제공
    final regex = RegExp(r'(\$.*?\$|\\.*?\b|P_a=.*?\[kVA\])');
    final matches = regex.allMatches(content ?? '');

    int lastIndex = 0;
    final List<InlineSpan> spans = [];

    for (final match in matches) {
      if (match.start > lastIndex) {
        spans.add(TextSpan(text: content!.substring(lastIndex, match.start)));
      }

      final equation = match.group(0);
      if (equation != null) {
        spans.add(_buildMathWidget(equation));
      }

      lastIndex = match.end;
    }

    if (lastIndex < content!.length) {
      spans.add(TextSpan(text: content.substring(lastIndex)));
    }

    return spans;
  }

  InlineSpan _buildMathWidget(String equation) {
    if (equation.startsWith(r'$') && equation.endsWith(r'$')) {
      equation = equation.substring(1, equation.length - 1);
    }

    return WidgetSpan(
      child: Container(
        padding: const EdgeInsets.only(bottom: 2.0),
        child: Math.tex(
          equation,
          textStyle: const TextStyle(fontSize: 18),
        ),
      ),
      alignment: PlaceholderAlignment.baseline,
      baseline: TextBaseline.alphabetic,
    );
  }
}
////////////////// (모든문제해결)
import 'package:flutter/material.dart';
import 'package:flutter_math_fork/flutter_math.dart';
import 'package:test_rendering/data/content_repository.dart';
import 'package:test_rendering/models/content.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Auto Text and LaTeX Renderer',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('Auto Text and LaTeX Renderer'),
        ),
        body: const Padding(
          padding: EdgeInsets.all(16.0),
          child: ContentRenderer(),
        ),
      ),
    );
  }
}

class ContentRenderer extends StatefulWidget {
  const ContentRenderer({super.key});

  @override
  _ContentRendererState createState() => _ContentRendererState();
}

class _ContentRendererState extends State<ContentRenderer> {
  int? selectedYear = 2024; // 기본값: 2024년
  int? selectedRound = 1; // 기본값: 1회차
  late Future<List<Content>> contents;

  @override
  void initState() {
    super.initState();
    contents = ContentRepository().fetchContents();
  }

  void _onYearChanged(int? newYear) {
    setState(() {
      selectedYear = newYear;
      contents = ContentRepository().fetchContents(); // 연도 변경에 따른 데이터 업데이트
    });
  }

  void _onRoundChanged(int? newRound) {
    setState(() {
      selectedRound = newRound;
      contents = ContentRepository().fetchContents(); // 회차 변경에 따른 데이터 업데이트
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            const Text('연도: ', style: TextStyle(fontSize: 20)),
            DropdownButton<int>(
              value: selectedYear,
              onChanged: _onYearChanged,
              items: List.generate(2025 - 2020, (index) {
                int year = 2024 - index;
                return DropdownMenuItem<int>(
                  value: year,
                  child: Text(year.toString()),
                );
              }),
            ),
          ],
        ),
        Row(
          children: [
            const Text('회차: ', style: TextStyle(fontSize: 20)),
            for (int round = 1; round <= 3; round++)
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 5),
                child: CircleAvatar(
                  child: TextButton(
                    onPressed: () => _onRoundChanged(round),
                    child:
                        Text("$round회", style: const TextStyle(fontSize: 14)),
                  ),
                ),
              ),
          ],
        ),
        const SizedBox(height: 20),
        FutureBuilder<List<Content>>(
          future: contents,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator());
            } else if (snapshot.hasError) {
              return Center(child: Text('Error: ${snapshot.error}'));
            } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
              return const Center(child: Text('No content available.'));
            }

            final List<Content> contentList = snapshot.data!;
            return Expanded(
              child: ListView.builder(
                itemCount: contentList.length,
                itemBuilder: (context, index) {
                  final content = contentList[index];
                  String questionNumber = content.nr.toString().length >= 8
                      ? int.parse(content.nr.toString().substring(6, 8))
                          .toString()
                      : (index + 1).toString();

                  return ListTile(
                    title: Text("$questionNumber. ${content.title}"),
                    onTap: () {
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) =>
                              ProblemDetailPage(content: content),
                        ),
                      );
                    },
                  );
                },
              ),
            );
          },
        ),
      ],
    );
  }
}

class ProblemDetailPage extends StatelessWidget {
  final Content content;

  const ProblemDetailPage({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    String nr = content.nr.toString();
    String questionNumber =
        nr.length >= 8 ? int.parse(nr.substring(6, 8)).toString() : '??';

    String title = content.title;
    final List<InlineSpan> questionSpans = _parseMixedContent(content.ques);
    final List<InlineSpan> answerSpans = _parseMixedContent(content.ans);

    return Scaffold(
      appBar: AppBar(
        title: const Text('문제 상세'),
      ),
      body: SingleChildScrollView(
        // 스크롤 가능하도록 수정
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "$questionNumber. $title",
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Container(
              color: Colors.grey[200],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  RichText(
                    text: TextSpan(
                      children: questionSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  if (content.qImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.qImgPath!),
                    ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            Container(
              color: Colors.teal[50],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  RichText(
                    text: TextSpan(
                      children: answerSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  if (content.aImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.aImgPath!),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<InlineSpan> _parseMixedContent(String? content) {
    final regex = RegExp(r'(\$.*?\$|\\.*?\b|P_a=.*?\[kVA\])');
    final matches = regex.allMatches(content ?? '');

    int lastIndex = 0;
    final List<InlineSpan> spans = [];

    for (final match in matches) {
      if (match.start > lastIndex) {
        spans.add(TextSpan(text: content!.substring(lastIndex, match.start)));
      }

      final equation = match.group(0);
      if (equation != null) {
        spans.add(_buildMathWidget(equation));
      }

      lastIndex = match.end;
    }

    if (lastIndex < content!.length) {
      spans.add(TextSpan(text: content.substring(lastIndex)));
    }

    return spans;
  }

  InlineSpan _buildMathWidget(String equation) {
    if (equation.startsWith(r'$') && equation.endsWith(r'$')) {
      equation = equation.substring(1, equation.length - 1);
    }

    return WidgetSpan(
      child: Container(
        padding: const EdgeInsets.only(bottom: 2.0),
        child: Math.tex(
          equation,
          textStyle: const TextStyle(fontSize: 18),
        ),
      ),
      alignment: PlaceholderAlignment.baseline,
      baseline: TextBaseline.alphabetic,
    );
  }
}
///////////////////(목록 배경색 추가) ->APK 출시
import 'package:flutter/material.dart';
import 'package:flutter_math_fork/flutter_math.dart';
import 'package:test_rendering/data/content_repository.dart';
import 'package:test_rendering/models/content.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Auto Text and LaTeX Renderer',
      home: Scaffold(
        appBar: AppBar(
          title: const Text('전기기사 실기 기출문제',
              style: TextStyle(fontSize: 30, fontWeight: FontWeight.bold)),
        ),
        body: const Padding(
          padding: EdgeInsets.all(16.0),
          child: ContentRenderer(),
        ),
      ),
    );
  }
}

class ContentRenderer extends StatefulWidget {
  const ContentRenderer({super.key});

  @override
  _ContentRendererState createState() => _ContentRendererState();
}

class _ContentRendererState extends State<ContentRenderer> {
  int? selectedYear = 2024; // 기본값: 2024년
  int? selectedRound = 1; // 기본값: 1회차
  late Future<List<Content>> contents;

  @override
  void initState() {
    super.initState();
    contents = ContentRepository().fetchContents();
  }

  void _onYearChanged(int? newYear) {
    setState(() {
      selectedYear = newYear;
      _filterContents(); // 데이터를 필터링하여 다시 로드
    });
  }

  void _onRoundChanged(int? newRound) {
    setState(() {
      selectedRound = newRound;
      _filterContents(); // 데이터를 필터링하여 다시 로드
    });
  }

  void _filterContents() {
    // 기존 데이터를 필터링
    contents = ContentRepository().fetchContents().then((data) {
      return data.where((content) {
        final nrString = content.nr.toString();
        final year = int.tryParse(nrString.substring(0, 4));
        final round = int.tryParse(nrString.substring(4, 6));
        return year == selectedYear && round == selectedRound;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 연도와 회차 선택
        Row(
          children: [
            const Text('연도: ',
                style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
            DropdownButton<int>(
              value: selectedYear,
              onChanged: _onYearChanged,
              items: List.generate(2025 - 2020, (index) {
                int year = 2024 - index;
                return DropdownMenuItem<int>(
                  value: year,
                  child: Text(
                    year.toString(),
                    style: const TextStyle(fontSize: 22), // 폰트 크기 변경
                  ),
                );
              }),
            ),
          ],
        ),
        Row(
          children: [
            const Text('회차: ',
                style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
            for (int round = 1; round <= 3; round++)
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 5),
                child: CircleAvatar(
                  child: TextButton(
                    onPressed: () => _onRoundChanged(round),
                    child: Text("$round", style: const TextStyle(fontSize: 20)),
                  ),
                ),
              ),
          ],
        ),
        const SizedBox(height: 20),

        // 문제 목록 부분
        Expanded(
          child: Container(
            color: Colors.blue[50], // 배경색 지정
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // 문제 목록 제목
                const Text(
                  '문제 목록',
                  style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 10),

                // 리스트뷰
                Expanded(
                  child: FutureBuilder<List<Content>>(
                    future: contents,
                    builder: (context, snapshot) {
                      if (snapshot.connectionState == ConnectionState.waiting) {
                        return const Center(child: CircularProgressIndicator());
                      } else if (snapshot.hasError) {
                        return Center(child: Text('Error: ${snapshot.error}'));
                      } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
                        return const Center(
                            child: Text('No content available.'));
                      }

                      final List<Content> contentList = snapshot.data!;
                      return ListView.builder(
                        itemCount: contentList.length,
                        itemExtent: 50, // 각 항목의 높이를 고정
                        itemBuilder: (context, index) {
                          final content = contentList[index];
                          String questionNumber = content.nr
                                      .toString()
                                      .length >=
                                  8
                              ? int.parse(content.nr.toString().substring(6, 8))
                                  .toString()
                              : (index + 1).toString();

                          return ListTile(
                            contentPadding:
                                EdgeInsets.zero, // ListTile 기본 여백 제거
                            title: Transform.scale(
                              scale: 0.95, // 텍스트 크기 압축
                              child: Text(
                                "$questionNumber. ${content.title}",
                                style: const TextStyle(
                                  fontSize: 20,
                                  height: 0.8, // 줄 간격 조정
                                ),
                              ),
                            ),
                            onTap: () {
                              Navigator.push(
                                context,
                                MaterialPageRoute(
                                  builder: (context) =>
                                      ProblemDetailPage(content: content),
                                ),
                              );
                            },
                          );
                        },
                      );
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

class ProblemDetailPage extends StatelessWidget {
  final Content content;

  const ProblemDetailPage({super.key, required this.content});

  @override
  Widget build(BuildContext context) {
    String nr = content.nr.toString();
    String questionNumber =
        nr.length >= 8 ? int.parse(nr.substring(6, 8)).toString() : '??';

    String title = content.title;
    final List<InlineSpan> questionSpans = _parseMixedContent(content.ques);
    final List<InlineSpan> answerSpans = _parseMixedContent(content.ans);

    return Scaffold(
      appBar: AppBar(
        title: const Text('문제 상세'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              "$questionNumber. $title",
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 10),
            Container(
              color: Colors.grey[200],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  RichText(
                    text: TextSpan(
                      children: questionSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  if (content.qImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.qImgPath!),
                    ),
                ],
              ),
            ),
            const SizedBox(height: 20),
            Container(
              color: Colors.teal[50],
              padding: const EdgeInsets.all(8.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  RichText(
                    text: TextSpan(
                      children: answerSpans,
                      style: const TextStyle(fontSize: 18, color: Colors.black),
                    ),
                  ),
                  if (content.aImgPath != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 8.0),
                      child: Image.asset(content.aImgPath!),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  List<InlineSpan> _parseMixedContent(String? content) {
    final regex = RegExp(r'(\$.*?\$|\\.*?\b|P_a=.*?\[kVA\])');
    final matches = regex.allMatches(content ?? '');

    int lastIndex = 0;
    final List<InlineSpan> spans = [];

    for (final match in matches) {
      if (match.start > lastIndex) {
        spans.add(TextSpan(text: content!.substring(lastIndex, match.start)));
      }

      final equation = match.group(0);
      if (equation != null) {
        spans.add(_buildMathWidget(equation));
      }

      lastIndex = match.end;
    }

    if (lastIndex < content!.length) {
      spans.add(TextSpan(text: content.substring(lastIndex)));
    }

    return spans;
  }

  InlineSpan _buildMathWidget(String equation) {
    if (equation.startsWith(r'$') && equation.endsWith(r'$')) {
      equation = equation.substring(1, equation.length - 1);
    }

    return WidgetSpan(
      child: Container(
        padding: const EdgeInsets.only(bottom: 2.0),
        child: Math.tex(
          equation,
          textStyle: const TextStyle(fontSize: 18),
        ),
      ),
      alignment: PlaceholderAlignment.baseline,
      baseline: TextBaseline.alphabetic,
    );
  }
}
